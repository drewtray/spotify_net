# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_retrieve_spotify_data.ipynb.

# %% auto 0
__all__ = ['SpotifyAPI']

# %% ../nbs/00_retrieve_spotify_data.ipynb 4
import requests
import base64
import json
import pandas as pd
import boto3
import math
import os
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

from datetime import date, timedelta

# %% ../nbs/00_retrieve_spotify_data.ipynb 5
class SpotifyAPI:
    """
    A class for interacting with the Spotify API.

    Parameters
    ----------
    region_name : str
        The name of the AWS region where the secrets manager is located.
    playlist_id : str
        The ID of the Spotify playlist.
    """
    required_env_keys = ['spot_clientID', 'spot_clientSECRET', 'spot_ACC', 'spot_REF']

    def __init__(self, region_name):
        """
        Initializes a new instance of the SpotifyAPI class.

        Parameters
        ----------
        region_name : str
            The name of the AWS region where the secrets manager is located.
        """
        self.region_name = region_name
        self.playlist_id = None
        self.df_tracks = pd.DataFrame()
    
    def get_secret(self, secret_name):
        """
        Retrieves the specified secret from AWS Secrets Manager and sets the corresponding environment variables.

        Parameters
        ----------
        secret_name : str
            The name of the secret to retrieve.
        """
        if all([k in os.environ.keys() for k in self.required_env_keys]):
            print('All required environment variables are set')
        else:
            session = boto3.session.Session()
            client = session.client(
                service_name='secretsmanager',
                region_name=self.region_name
            )
            secret_value = client.get_secret_value(
                SecretId=secret_name
            )
            secret_dict = json.loads(secret_value['SecretString'])
            for k, v in secret_dict.items():
                os.environ[k] = v

    def create_headers(self):
        """
        Creates the headers required for making requests to the Spotify API.

        Returns
        -------
        dict
            A dictionary containing the required headers.
        """
        return {
            'Authorization': f'Bearer {os.environ.get("spot_ACC")}'
        }

    def refresh_token(self):
        """
        Refreshes the access token required for making requests to the Spotify API.
        """
        TOKEN_URL = 'https://accounts.spotify.com/api/token'

        message = os.environ.get('spot_clientID') + ':' + os.environ.get('spot_clientSECRET')
        messageBytes = message.encode('ascii')
        base64Bytes = base64.b64encode(messageBytes)
        base64Message = base64Bytes.decode('ascii')

        headers = {
            'Authorization': 'Basic ' + base64Message,
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        pars_refresh = {
            'grant_type': 'refresh_token',
            'refresh_token': os.environ.get('spot_REF'),
            'redirect_uri': 'http://localhost:8888/callback',
        }

        r_refresh = requests.post(TOKEN_URL, headers=headers, params=pars_refresh)
        access_token = r_refresh.json()['access_token']
        os.environ['spot_ACC'] = access_token

    def get_track_subset(self, playlist_id, offset):
        """
        Retrieves a subset of tracks from the specified Spotify playlist.

        Parameters
        ----------
        playlist_id : str
            The ID of the Spotify playlist to retrieve tracks from.
        offset : int
            The offset to use when retrieving tracks.

        Returns
        -------
        list
            A list of track items.
        """
        track_url = f'https://api.spotify.com/v1/playlists/{playlist_id}/tracks?limit=100&offset={offset}'
        headers = self.create_headers()
        track_subset = requests.get(track_url, headers=headers)

        if track_subset.status_code == 401:
            self.refresh_token()
            headers = self.create_headers()
            track_subset = requests.get(track_url, headers=headers)
        
        return track_subset.json()['items']
    
    def get_subset_features(self, track_items):
        """
        Given a list of track items, returns a pandas DataFrame containing information about each track, including the track ID, name, artist, artist ID, and audio features such as danceability, energy, and tempo.

        Parameters
        ----------
        track_items : list
            A list of track items, where each item is a dictionary containing information about a track.

        Returns
        -------
        pandas.DataFrame
            A DataFrame containing information about each track, including the track ID, name, artist, artist ID, and audio features such as danceability, energy, and tempo.
        """
        track_ids = [t['track']['id'] for t in track_items]
        track_names = [t['track']['name'] for t in track_items]
        track_added = [t['added_at'] for t in track_items]
        track_artists = [t['track']['artists'][0]['name'] for t in track_items]
        artist_id = [t['track']['artists'][0]['id'] for t in track_items]

        track_info = pd.DataFrame({
            'added at': pd.to_datetime(track_added),
            'id': track_ids,
            'name': track_names,
            'artist': track_artists,
            'artist id': artist_id,
            })

        track_id_list = ','.join(track_ids)
        # TODO: look into 'Audio Analysis' endpoint: https://developer.spotify.com/documentation/web-api/reference/get-audio-analysis
        feat_url = f'https://api.spotify.com/v1/audio-features?ids={track_id_list}'
        headers = self.create_headers()
        r_feat = requests.get(feat_url, headers=headers)
        feat_frame = pd.DataFrame(r_feat.json()['audio_features'])
        track_features = pd.concat([track_info, feat_frame], axis=1)

        return track_features 

    def get_playlist_features(self, playlist_id):
        """
        Given a Spotify playlist ID, returns a pandas DataFrame containing information about all the tracks in the playlist, including the track ID, name, artist, artist ID, and audio features such as danceability, energy, and tempo.

        Parameters
        ----------
        playlist_id : str
            The ID of the Spotify playlist.

        Returns
        -------
        pandas.DataFrame
            A DataFrame containing information about all the tracks in the playlist, including the track ID, name, artist, artist ID, and audio features such as danceability, energy, and tempo.
        """
        offset = 0
        # TODO: has default limit changed to 50? https://developer.spotify.com/documentation/web-api/reference/get-playlists-tracks

        while True:
            subset = self.get_track_subset(playlist_id, offset)
            self.df_tracks = self.df_tracks.append(self.get_subset_features(subset))

            if len(self.df_tracks) < 100:  # less than 100 tracks in the response, we've fetched all tracks
                break

            offset += 100

        self.df_tracks = self.df_tracks.drop_duplicates()

    
    def get_artist_info(self, df_tracks, headers):
        """
        """
        pass

    def process_genres(self, df_tracks):
        """
        """
        pass

    def parse_new_tracks(self, lookback_days=7):
        """
        Sorts tracks based on when they were added and filters out tracks added more than 'lookback_days' ago.
        Returns two DataFrames: one containing the new tracks added within the lookback period, and one containing the old tracks added before the lookback period.

        Parameters
        ----------
        lookback_days : int, optional
            The number of days to look back for new tracks. Defaults to 7.

        Returns
        -------
        pandas.DataFrame
            A DataFrame containing the old tracks added before the lookback period.
        pandas.DataFrame
            A DataFrame containing the new tracks added within the lookback period.
        """
        self.df_tracks = self.df_tracks.sort_values('added at')
        today = pd.to_datetime(date.today(), utc=True)

        # Calculate the time difference between track addition and 'today'
        self.df_tracks['diff'] = self.df_tracks['added at'].apply(lambda x: today - x)
        lookback_period = timedelta(days=lookback_days)

        # Filter tracks based on the lookback period
        new_tracks = self.df_tracks[self.df_tracks['diff'].apply(lambda x: x <= lookback_period)]
        old_tracks = self.df_tracks[self.df_tracks['diff'].apply(lambda x: x > lookback_period)]

        return old_tracks, new_tracks

    def delete_tracks(self, tracks_to_delete):
        """
        Deletes a batch of tracks from a Spotify playlist.

        Parameters
        ----------
        tracks_to_delete : pandas.DataFrame
            A DataFrame containing the tracks to be deleted, where each row represents a track and contains a 'uri' column with the URI of the track.

        Returns
        -------
        None
        """
        to_delete = tracks_to_delete['uri'].tolist()  # Assuming 'uri' is the column name in your DataFrame
        num_tracks = len(to_delete)
        num_batches = math.ceil(num_tracks/100)

        for i in range(0, num_batches*100, 100):
            delete_uris = to_delete[i:(i+100)]
            uri_dict = [{'uri': uri} for uri in delete_uris]
            del_dict = {'tracks': uri_dict}
            headers = self.create_headers()
            DELETE_URL = f'https://api.spotify.com/v1/playlists/{self.playlist_id}/tracks'
            r_delete = requests.delete(DELETE_URL, data=json.dumps(del_dict))



# %% ../nbs/00_retrieve_spotify_data.ipynb 14
if __name__ == '__main__':
    spot = SpotifyAPI('us-east-2')
    spot.get_secret('spotify_35')
    spot.get_playlist_features('3ubgXaHeBn1CWLUZPXvqkj')
    # old_tracks, new_tracks = spot.parse_new_tracks(lookback_days=7)
    # new_tracks.to_csv('s3://spotify-net/newer_tracks.csv')
    # spot.delete_tracks(old_tracks)
    # print('Updated')
